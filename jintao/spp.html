<!--
@license
Copyright 2022 Taiwan (ChungYi Fu)
SPDX-License-Identifier: Apache-2.0

@fileoverview Web Serial
@author https://www.facebook.com/francefu/
@Update 1/26/2022 21:30 (Taiwan Standard Time)
 
Web Serial
https://web.dev/serial/

Try it
https://fustyles.github.io/webduino/WebSerial.html
-->

<!DOCTYPE HTML>
<html>
<head>
  <title>台科大智慧枕墊資料收集系統</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<style>
#title {
  background-color: blue;
  color: white;
  font-size: 36px;
  text-align: center;
  padding: 20px;
}
</style>  
</head>
<body>
<div id="title">台科大林上智教授團隊智慧枕墊資料收集系統</div>

<table>

<td style="vertical-align:top"> 

<table>

<tr>
<td>Baud Rate
<select id="serial_baud">
    <option value="115200">115200</option>
    <option value="9600">9600</option>
    <option value="300">300</option>
    <option value="1200">1200</option>
    <option value="2400">2400</option>
    <option value="4800">4800</option>
    <option value="19200">19200</option>
    <option value="38400">38400</option>
    <option value="57600">57600</option>
    <option value="74880">74880</option>
    <option value="230400">230400</option>
    <option value="250000">250000</option>
    <option value="500000">500000</option>
    <option value="1000000">1000000</option>	
    <option value="2000000">2000000</option>		
</select>
</td>
<td><button id="serial_close_port">Close Port</button><button id="serial_request_port">Select Port</button></td>
	
	
	
	
</tr>

<tr>
<td><input type="text" id="serial_text">
<select id="serial_newline">
    <option value=""></option>
    <option value="\r">\r</option>	
    <option value="\n">\n</option>	
    <option value="\r\n">\r\n</option>		
</select>
</td>
<td><button id="serial_sendText">Send Text</button></td>
</tr>

<tr>
<td><input type="text" id="serial_uint8" value="">
</td>
<td><button id="serial_sendUint8">Send Uint8Array</button></td>
</tr>

<td><button id="syncTime">Sync UTC Time</button></td>
<td><button id="exportData">Export Data</button></td>
<tr>
<td colspan="2"><div id="serial_status" style="width:400px;height:400px;border:2px black solid;overflow: auto;"></div></td>
</tr>
<tr>
<td>
</td>
<td align="right">
<button id="serial_clearText">Clear Text</button>
</td>
</tr>
</table>
</td>

<td  style="vertical-align:top">
<div  style="height: 200px"><canvas id="pressureChart"></canvas>
<canvas id="averChart"></canvas>
<canvas id="diffChart"></canvas>
<canvas id="prev5Chart"></canvas>
<canvas id="stateChart"></canvas>
<canvas id="onoffChart"></canvas>
<canvas id="pPoseChart"></canvas>
<canvas id="poseChart"></canvas>	</div>
</td>
</table>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>

let serial_baud = document.getElementById('serial_baud');
let serial_text = document.getElementById('serial_text');
let serial_uint8 = document.getElementById('serial_uint8');
let serial_status = document.getElementById('serial_status');
let serial_buttonRequest = document.getElementById('serial_request_port');
let serial_buttonClose = document.getElementById('serial_close_port');
let serial_sendText = document.getElementById('serial_sendText');
let serial_sendUint8 = document.getElementById('serial_sendUint8');
let serial_clearText = document.getElementById('serial_clearText');
let serial_newline = document.getElementById('serial_newline');
let serial_syncTime = document.getElementById('syncTime');
let db_exportData = document.getElementById('exportData');

let serial_port = null;
let serial_textEncoder = {};
let serial_writableStreamClosed = {};
let serial_writer = {};
let serial_reader = null;
let serial_readSting = "";
let serial_keepReading = true;
let serial_selProductId = "";
let serial_selVendorId = "";
let serial_timer;

let serial_ready = false;

        // Initialize the chart
        const ctx = document.getElementById('pressureChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',  // Chart type (line, bar, etc.)
            data: {
                labels: [],  // Array for x-axis labels (timestamps, etc.)
                datasets: [{
                    label: 'Detect',
                    data: [],  // Array for data points (sensor values)
                    fill: false,
                    borderColor: 'rgb(175, 71, 71)',
					borderWidth: 1,
                    pointRadius: 1
                }, {
                    label: 'Neck',
                    data: [],
                    fill: false,
                    borderColor: 'rgb(5, 192, 2)',
					borderWidth: 1,
                    pointRadius: 1
                }, {
                    label: 'Head',
                    data: [],
                    fill: false,
                    borderColor: 'rgb(5, 2, 192)',
					borderWidth: 1,
                    pointRadius: 1
                }]
            },
            options: {
				maintainAspectRatio: false,
                scales: {
					y: {
						max: 1500,
						min: 500,
					},
                    yAxes: [{
                        ticks: {
                            beginAtZero: true
                        }
                    }],
					x: { 
						ticks: { 
							font: { 
								size: 8, // 設定 x 軸標籤的字體大小
							} 
						} 
					}, 
					xAxes: [{
						ticks: {
							fontSize: 1,
						},
						type: 'string',
                    
						display: true,
						scaleLabel: {
							display: true,
							labelString: 'value'
						}                        
											
					}]
                }
            }
        });

        const ctx2 = document.getElementById('averChart').getContext('2d');
        const chart2 = new Chart(ctx2, {
            type: 'line',  // Chart type (line, bar, etc.)
            data: {
                labels: [],  // Array for x-axis labels (timestamps, etc.)
                datasets: [{
				
                    label: 'last5',
                    data: [],  // Array for data points (sensor values)
                    fill: false,
                    borderColor: 'rgb(175, 71, 71)',
					borderWidth: 1,
                    pointRadius: 1
                },{
			
                    label: 'prev5',
                    data: [],  // Array for data points (sensor values)
                    fill: false,
                    borderColor: 'rgb(175, 71, 171)',
					borderWidth: 1,
                    pointRadius: 1
					}]
			},				
            options: {
				maintainAspectRatio: false,
                scales: {
					y: {
						max: 1500,
						min: 500,
					},
                    yAxes: [{
                        ticks: {
                            beginAtZero: true,
                        }
                    }],
					x: { 
						ticks: { 
							font: { 
								size: 8, // 設定 x 軸標籤的字體大小
							} 
						} 
					}, 
					xAxes: [{
						type: 'string',
                    
						display: true,
						scaleLabel: {
							display: true,
							labelString: 'value'
						}                        
											
					}]
                }
            }
        });

        const ctx3 = document.getElementById('diffChart').getContext('2d');
        const chart3 = new Chart(ctx3, {
            type: 'line',  // Chart type (line, bar, etc.)
            data: {
                labels: [],  // Array for x-axis labels (timestamps, etc.)
                datasets: [{
                    label: 'Diff',
                    data: [],  // Array for data points (sensor values)
                    fill: false,
                    borderColor: 'rgb(75, 71, 171)',
					borderWidth: 1,
                    pointRadius: 1
				}]
            },			
            options: {
				maintainAspectRatio: false,
                scales: {
                    yAxes: [{
                        ticks: {
                            beginAtZero: true,
                        }
                    }],
					x: { 
						ticks: { 
							font: { 
								size: 8, // 設定 x 軸標籤的字體大小
							} 
						} 
					}, 
					xAxes: [{
						type: 'string',
                    
						display: true,
						scaleLabel: {
							display: true,
							labelString: 'value'
						}                        
											
					}]
                }
            }
        });
 
// indexeddb
// indexedDB操作模組
const DBModule = (function() {
  let dbName;
  const storeName = 'dataStore';
  let db;

  function initDB(timestamp) {
    dbName = `MyDataDB_${timestamp}`;
    return openDB();
  }

  function openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(dbName, 1);
      
      request.onerror = event => reject(`Database error: ${event.target.error}`);
      
      request.onsuccess = event => {
        db = event.target.result;
        resolve(db);
      };
      
      request.onupgradeneeded = event => {
        const db = event.target.result;
        db.createObjectStore(storeName, { keyPath: 'timestamp' });
      };
    });
  }

  function saveData(data) {
    return new Promise((resolve, reject) => {
      if (!db) {
        reject('Database not initialized');
        return;
      }

      const transaction = db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);

      const timestamp = new Date().toISOString();
      const dataWithTimestamp = { timestamp, values: data };

      const request = store.add(dataWithTimestamp);

      request.onerror = event => reject(`Error saving data: ${event.target.error}`);
      request.onsuccess = event => resolve(event.target.result);
    });
  }

  function getAllData() {
    return new Promise((resolve, reject) => {
      if (!db) {
        reject('Database not initialized');
        return;
      }

      const transaction = db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.getAll();

      request.onerror = event => reject(`Error getting data: ${event.target.error}`);
      request.onsuccess = event => resolve(event.target.result);
    });
  }

  function exportToCSV() {
    return getAllData().then(data => {
      let csvContent = 'timestamp,value1,value2,value3,value4,value5,value6,value7,value8,value9,value10\n';
      
      data.forEach(item => {
        const row = [item.timestamp, ...item.values].join(',');
        csvContent += row + '\n';
      });

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `data_export_${dbName}.csv`);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  }

  return {
    init: initDB,
    save: saveData,
    getAll: getAllData,
    exportCSV: exportToCSV
  };
})();

const startTimestamp = new Date().toISOString().replace(/[:.]/g, '-');
DBModule.init(startTimestamp).then(() => {
  console.log('Database ready');
}).catch(error => {
  console.error('Database initialization error:', error);
});

// serial	
navigator.serial.addEventListener("connect", (event) => {
  serial_message("Device connect","red");
});

navigator.serial.addEventListener("disconnect", (event) => {
	serial_message("Device disconnect","red");
});	
			
async function readUntilClosed() {
  while (serial_port.readable && serial_keepReading) {
	serial_reader = serial_port.readable.getReader();
	try {
	  while (true) {
		const { value, done } = await serial_reader.read();
		if (done) {
		  // |reader| has been canceled.
		  break;
		}
		if (value) {
			serial_readSting += new TextDecoder().decode(value);
			if (value.includes(10)) {    //Serial.println(data);
				clearTimeout(serial_timer);
				console.log(serial_readSting);
				serial_message(serial_readSting,"green");
				serial_readSting = "";
			}
			else {    //Serial.print(data);
				serial_timer = setTimeout(function() {
					if (serial_readSting != "") 
						serial_message(serial_readSting,"green");
					serial_readSting = "";
				}, 10);
			}
		}
	  }
	} catch (error) {
	  // Handle |error|...
	} finally {
	  serial_reader.releaseLock();
	}
  }
}

var chart_data_count = 0;
function fillChartArray() {
	
	for (var i=0; i<50; i++) {
		chart.data.labels.push("");
		chart.data.datasets[0].data.push(0);
		chart.data.datasets[1].data.push(0);
		chart.data.datasets[2].data.push(0);
		chart2.data.labels.push("");
		chart2.data.datasets[0].data.push(0);
		chart2.data.datasets[1].data.push(0);
		chart3.data.labels.push("");
		chart3.data.datasets[0].data.push(0);
	}
	chart_data_count = 50;
}

serial_buttonRequest.addEventListener('click', async () => {
	if ("serial" in navigator) {
		/*
		const filters = [
			{ usbVendorId: 0x2341, usbProductId: 0x43 },
			{ usbVendorId: 0x2341, usbProductId: 0x01 }
		];
		*/
		const filters = [];
		
		serial_port = await navigator.serial.requestPort({ filters });
		const { usbProductId, usbVendorId } = serial_port.getInfo();
		serial_selProductId = (usbProductId)?"0x"+usbProductId:"null";
		serial_selVendorId = (usbVendorId)?"0x"+usbVendorId:"null";
		
		serial_keepReading = true;
		
		try {
			var rate =  Number(serial_baud.value);
			await serial_port.open({ baudRate: rate });
			var msg = "VendorId: "+serial_selVendorId.toString(16)+" ProductId: "+serial_selProductId.toString(16)+" Ready!";
			serial_message(msg,"blue");
			
			//await serial_port.setSignals({ dataTerminalReady: false });
			//await new Promise(resolve => setTimeout(resolve, 200));
			//await serial_port.setSignals({ dataTerminalReady: true });

			const closed = readUntilClosed();
			
			serial_ready = true;
			fillChartArray();
		} catch (error) {
			var errorString = error.message;
			if (errorString.indexOf("already open")!=-1) {
				var msg = "VendorId: 0x"+serial_selVendorId.toString(16)+" ProductId: 0x"+serial_selProductId.toString(16)+" Ready!";
				serial_message(msg,"blue");
			}
			else if (errorString.indexOf("Failed to open serial port")!=-1) {
				setTimeout(function(){serial_buttonRequest.click();},1000);
			}
			else {
				serial_message(errorString,"red");
			}
		}
	}
		
});

serial_buttonClose.addEventListener('click', async () => {
	try {
		if (serial_port) {	
			/*
			serial_keepReading = false;
			serial_reader.cancel();
			await closed;
			*/
			
			serial_port.close();
			serial_port = null;
			serial_message("Closed","blue");
		}
	} catch (error) {
			serial_message(error.message,"red");
	}	
});

serial_sendText.addEventListener('click', async () => {
	serial_sendUint8.disabled = true;
	if (serial_port&&serial_writer) {
		try {
			serial_newline.value = serial_newline.value.replace(/\\n/g, "\n");
			serial_newline.value = serial_newline.value.replace(/\\r/g, "\r");
			var msg = serial_text.value + serial_newline.value;
			serial_message(msg,"orange");
			serial_text.value = "";
			
			if (!serial_textEncoder[serial_selProductId])
				serial_textEncoder[serial_selProductId] = new TextEncoderStream();
			if (!serial_writableStreamClosed[serial_selProductId])
				serial_writableStreamClosed[serial_selProductId] = serial_textEncoder[serial_selProductId].readable.pipeTo(serial_port.writable);
				
			serial_writer[serial_selProductId] = serial_textEncoder[serial_selProductId].writable.getWriter();
			await serial_writer[serial_selProductId].write(msg).then(function() {
				serial_writer[serial_selProductId].releaseLock();
			});
		} catch (error) {
			serial_message(error.message,"red");
		}
	}
});

serial_sendUint8.addEventListener('click', async () => {
	serial_sendText.disabled = true;
	if (serial_port&&serial_writer) {
		try {
			serial_message(serial_uint8.value,"orange");
			var intArray = serial_uint8.value.split(",");
			msg = String.fromCharCode.apply(null, intArray);
			serial_uint8.value = "";
						
			serial_writer[serial_selProductId] = serial_port.writable.getWriter();
			const data = new Uint8Array(intArray);
			await serial_writer[serial_selProductId].write(data).then(function() {
				serial_writer[serial_selProductId].releaseLock();
			});
		} catch (error) {
			serial_message(error.message,"red");
		}
	}
});

serial_clearText.addEventListener('click', async () => {
	serial_status.innerHTML = "";
});

serial_syncTime.addEventListener('click', async () => {
            const now = Math.floor(Date.now() / 1000); // 生成UNIX時間戳
            const utcString = now;//now.toISOString(); // 生成UTC時間字串
	if (serial_port&&serial_writer) {
		try {
			var msg = "synctime," + utcString  + serial_newline.value;
			serial_message(msg,"orange");
			serial_text.value = "";
			
			if (!serial_textEncoder[serial_selProductId])
				serial_textEncoder[serial_selProductId] = new TextEncoderStream();
			if (!serial_writableStreamClosed[serial_selProductId])
				serial_writableStreamClosed[serial_selProductId] = serial_textEncoder[serial_selProductId].readable.pipeTo(serial_port.writable);
				
			serial_writer[serial_selProductId] = serial_textEncoder[serial_selProductId].writable.getWriter();
			await serial_writer[serial_selProductId].write(msg).then(function() {
				serial_writer[serial_selProductId].releaseLock();
			});
		} catch (error) {
			serial_message(error.message,"red");
		}
	}
});

db_exportData.addEventListener('click', async () => {
	DBModule.exportCSV().then(() => {
	  console.log('CSV exported');
	}).catch(error => {
	  console.error('Export error:', error);
	});
});

function isValidFloatString3(inputString) {
  // Regular expression to match a valid floating-point number
  const floatRegex = /^-?\d+\.?\d*$/;

  // Split the input string into an array of strings
  const dataPoints = inputString.split(' ');

  // Check if the number of data points is exactly 3
  if (dataPoints.length !== 3) {
    return false;
  }
  
  // Check if each data point is a valid floating-point number
  return dataPoints.every(dataPoint => floatRegex.test(dataPoint));
}

function isValidData7(inputString) {
	const dataPoints = inputString.split(' ');
	if (dataPoints.length !== 7) {
		return false;
	}
	
	return true;
}

// P指令回傳: 三組壓力值的浮點數 分別代表: 監測 頸部 頭部
// I指令回傳: 七組內部變數值 分別代表:
//         differential, state, onoff_event, last5pointAvg, prev5pointAvg, predict_Pose, Pose_event
//
let pressure1, pressure2, pressure3, differential, state, onoff_event, last5pointAvg, prev5pointAvg, predict_Pose, Pose_event;

function serial_message(msg, colour) {
	serial_status.innerHTML += "<font color='"+colour+"'>"+msg+"</font><br>";
	serial_status.scrollTop = serial_status.scrollHeight;

            const dataString = msg.toString().replace('\r\n', '');  // Convert buffer data to string
            const dataPoints = dataString.split(' ').map(parseFloat);  // Parse data into numbers


			if (isValidFloatString3(dataString)) {
			
				// Update chart data and labels
				var now = new Date();
				if(chart_data_count%10 == 0){
					chart.data.labels.push(now.toISOString().slice(-13, -4));  // Add timestamp as label
				}else{
					chart.data.labels.push("");  // Add timestamp as label
				}
				if(chart_data_count > 50){
					chart.data.labels.shift();
				}
				dataPoints.forEach((value, index) => {
					chart.data.datasets[index].data.push(value);
					if (chart_data_count > 50) {
						chart.data.datasets[index].data.shift();
					}
					if (index == 0){
						pressure1 = value;
					}
					if (index == 1){
						pressure2 = value;
					}
					if (index == 2){
						pressure3 = value;
					}
				});
				// Update the chart
				chart.update();
			}
			
			if (isValidData7(dataString)) {
				dataPoints.forEach((value, index) => {
					if (index == 0) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"diff: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						// Update chart data and labels
						var now = new Date();
						if(chart_data_count%10 == 0){
							chart3.data.labels.push(now.toISOString().slice(-13, -4));  // Add timestamp as label
						}else{
							chart3.data.labels.push("");  // Add timestamp as label
						}
						if(chart_data_count > 50){
							chart3.data.labels.shift();
						}
						chart3.data.datasets[0].data.push(value);
						if(chart_data_count > 50){
							chart3.data.datasets[0].data.shift();
						}
						differential = value;
				chart3.update();
					}
				
					if (index == 1) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"state: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						state = value;
					}
					if (index == 2) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"onoff: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						onoff_event = value;
					}
					if (index == 3) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"last5: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						// Update chart data and labels
						var now = new Date();
						if(chart_data_count%10 == 0){
							chart2.data.labels.push(now.toISOString().slice(-13, -4));  // Add timestamp as label
						}else{
							chart2.data.labels.push("");  // Add timestamp as label
						}
						if(chart_data_count > 50){
							chart2.data.labels.shift();
						}
						chart2.data.datasets[0].data.push(value);
						if(chart_data_count > 50){
							chart2.data.datasets[0].data.shift();
						}
						last5pointAvg = value;
					}
					if (index == 4) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"prev5: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						// Update chart data and labels
						chart2.data.datasets[1].data.push(value);
						if(chart_data_count > 50){
							chart2.data.datasets[1].data.shift();
						}
						prev5pointAvg = value;
				chart2.update();
					}
					if (index == 5) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"predict_pose: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						predict_Pose = value;
					}
					if (index == 6) {
						serial_status.innerHTML += "<font color='"+colour+"'>"+"pose: "+value+"</font><br>";
						serial_status.scrollTop = serial_status.scrollHeight;
						Pose_event = value;
					}
				});
				console.log(chart_data_count);
				chart_data_count++;

				
				// store to db
				const dataToSave = [pressure1, pressure2, pressure3, differential, last5pointAvg, prev5pointAvg, state, onoff_event, predict_Pose, Pose_event];
				DBModule.save(dataToSave).then(() => {
				  console.log('Data saved');
				}).catch(error => {
				  console.error('Save error:', error);
				});
			}
}
 var func_count=0;
 setInterval(async function() {
	if (serial_port&&serial_writer&&serial_ready) {
			
            var pString = "";
			if(func_count++ % 2 == 0){
				pString = "p" + "\n"; //serial_newline.value;
			}else{
				pString = "i" + "\n";
			}
		try {
			var msg = pString;
			//serial_message(msg,"orange");
			//serial_text.value = "";
			
			if (!serial_textEncoder[serial_selProductId])
				serial_textEncoder[serial_selProductId] = new TextEncoderStream();
			if (!serial_writableStreamClosed[serial_selProductId])
				serial_writableStreamClosed[serial_selProductId] = serial_textEncoder[serial_selProductId].readable.pipeTo(serial_port.writable);
				
			serial_writer[serial_selProductId] = serial_textEncoder[serial_selProductId].writable.getWriter();
			await serial_writer[serial_selProductId].write(msg).then(function() {
				serial_writer[serial_selProductId].releaseLock();
			});
		} catch (error) {
			serial_message(error.message,"red");
		}
	}
},1000);



</script>
</body>
</html>
